<style>

.node {
position: absolute;
background-color: gray;
display: grid;
place-items: center;
}
.textLine {
width: 50px;
height: 20px;
background-color: yellow;
display: grid;
place-items: center;
}
.stashCell {
width: 50px;
height: 20px;
border: 1px solid black;
}
.positionLabel {
position: absolute;
width: 50;
height: 50;
display: grid;
place-items: center;
}
.positionValue {
position: absolute;
width: 50;
height: 50;
border: 1px solid black;
display: grid;
place-items: center;
}
.highlight {
    background-color: red;
}
</style>

<div style="position: relative; width:500; height:500" id="treeContainer"></div>
<div style="position: relative" id="stashContainer"></div>
<div style="position: relative" id="positionContainer"></div>

<script>
const N = 8;
const L = 3;
const Z = 4;
const nodeWidth = 80;
const textLineHeight = 20;
const nodeHeight = (Z + 1) * textLineHeight;
const DUMMY = "_";

function createNode(l, parent, path, container) {
    let node = document.createElement("div")
    node.className = "node";
    node.id = "id-" + path;
    for (let i = 0; i < Z; i++) {
        let textLine = document.createElement("div");
        textLine.className = "textLine";
        textLine.innerHTML = DUMMY;
        node.appendChild(textLine);
    }
    if (l == L) {
        node.style.left = (parseInt(path, 2) * nodeWidth * 1.2) + "px" ;
        let label = document.createElement("div");
        label.className = "positionLabel";
        label.innerText = parseInt(path, 2);
        label.style.left = node.style.left;
        label.style.width = nodeWidth;
        label.style.height = 30;
        container.appendChild(label);
    } else {
        let c0 = createNode(l + 1, undefined, path + "0", container);
        let c1 = createNode(l + 1, undefined, path + "1", container);
        node.style.left = (c0.offsetLeft + c1.offsetLeft) / 2;
    }
    node.style.top = (L - l) * nodeHeight * 1.2 + 30;
    node.style.width = nodeWidth;
    node.style.height = nodeHeight;
    container.appendChild(node);
    return node;
}
createNode(0, undefined, "", document.querySelector("#treeContainer"));

function stashAppend(s) {
    if (s == DUMMY) return;
    let cell = document.createElement("span");
    cell.className = "stashCell";
    cell.innerText = s;
    let container = document.querySelector("#stashContainer");
    container.appendChild(cell);
}
function stashAppendAll(vals) {
    vals.forEach(v => stashAppend(v));
}
function stashUpdate(a, data) {
    let cell = [...document.querySelectorAll(".stashCell")].find(c => c.innerText.startsWith(a + " "));
    console.log("stashUpdate: cell: ", cell);
    if (cell) {
        cell.innerText = a + " " + data;
    } else {
        stashAppend(a + " " + data);
    }
}

function randomPosition() {
    return Math.floor(Math.random() * (2 ** L));
}

let positionContainer = document.querySelector("#positionContainer");
for (let i = 0; i < N; i++) {
    let label = document.createElement("div");
    label.className = "positionLabel";
    label.innerText = i;
    label.style.left = 50 * i;
    positionContainer.appendChild(label);

    let value = document.createElement("div");
    value.id = "p-" + i;
    value.className = "positionValue";
    value.innerText = randomPosition();
    value.style.left = 50 * i;
    value.style.top = 50;
    positionContainer.appendChild(value);
}
const DELAY = 1000;
function highlight(node) {
    console.log("highlight: add: ", node);
    node.classList.add("highlight");
    setTimeout(() => {
        console.log("remove highlight: ", node);
        node.classList.remove("highlight");
    }, DELAY);
    return node;
}
function position(a) {
    return highlight(document.getElementById("p-" + a));
}
function P(x, l) { // x: leaf index, l: level, return: a bucket div
    let path = ((1 << L) + Number(x)).toString(2).substring(1, 1 + l);
    return highlight(document.getElementById("id-" + path));
}
function readBucket(bucketNode) {
    console.log("readBucket: ", bucketNode);
    return [... bucketNode.childNodes].map(c => c.innerText);
}
function clearBucket(bucketNode) {
    [... bucketNode.childNodes].forEach(c => c.innerText = DUMMY);
}
function appendToBucket(bucketNode, s) {
    let emptyBlock = [... bucketNode.childNodes].find(c => c.innerText == DUMMY);
    if (emptyBlock) {
        emptyBlock.innerText = s;
        return true;
    } else {
        return false;
    }
}
function createTempBucket(origBucket) {
    let node = document.createElement("div")
    node.className = "node";
    node.id = "id-temp";
    for (let i = 0; i < Z; i++) {
        let textLine = document.createElement("div");
        textLine.className = "textLine";
        textLine.innerHTML = DUMMY;
        node.appendChild(textLine);
    }
    node.style.left = origBucket.offsetLeft + 10;
    node.style.top = origBucket.offsetTop + 10;
    node.style.width = nodeWidth;
    node.style.height = nodeHeight;
    origBucket.parentNode.appendChild(node);
    return node;
}
function writeBucket(origBucket, tempBucket) {
    for (let i = 0; i < Z; i++) {
        origBucket.children[i].innerText = tempBucket.children[i].innerText;
    }
}
async function access(op, a, data) {
    let x = Number(position(a).innerText);
    await sleep();
    position(a).innerText = randomPosition();
    await sleep();
    for (let l = 0; l <= L; l++) {
        stashAppendAll(readBucket(P(x, l)));
        await sleep();
    }
    if (op == "write") {
        stashUpdate(a, data);
    }
    for (let l = L; l >= 0; l--) {
        let tempBucket = createTempBucket(P(x, l));
        await sleep();
        [...document.querySelectorAll(".stashCell")].forEach(cell => {
            let [a2, data2] = cell.innerText.split(" ");
            console.log("x: ", x, " a2: ", a2, " data2: ", data2);
            if (P(x, l) == P(a2, l)) {
                if (appendToBucket(tempBucket, a2 + " " + data2)) {
                    cell.parentNode.removeChild(cell);
                }
            }
        });
        writeBucket(P(x, l), tempBucket);
        tempBucket.parentNode.removeChild(tempBucket);
    }
}
setTimeout(() => access("write", 5, 3), 2000);

async function sleep() {
  return new Promise((resolve) => setTimeout(resolve, 0));
}
</script>
